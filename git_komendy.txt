//C:\Users\USER\Atollic\TrueSTUDIO\STM32_workspace_9.3\Git_komendy
Repozytorium - pliki projektu + historia zmian
Repozytoria - zdalne, lokalne, 
Snapshot - migawka z aktualnego stanu projektu zapisywana w repozytorium komendą commit

Komendy konsoli
mkdir nazwa - tworzy katalog o nazwie nazwa
edycja pliku: code .\about.html  //otwiera w VS Code
            notepad .\about.html    // otwiera w notatniku
podejzenie pliku w konsoli: cat git_komendy.txt
echo "Przyklad" >> about.html       //tworzy plik about a w nim słowo: Przyklad
W Git-bush nie powershell! można tworzyć pliki :
    >> plik.txt
ale też
    > plik2.txt //z jednym nawiasem nie chroni przed nadpisaniem
rm plik.txt kasuje plik
rm *.html //kasuje wszystkie pliki html
rm -force .\udp2raw-tunnel\ //usuwa katalog ze wszystkimi plikami także ukrytymi

Otwieranie konsoli ctrl + ~
                    ctrl + j 

VS Code
zmiana defoltowej scieżki:
File -> Preferences -> Settings
terminal.integrated.cwd

git commit -m "co sie zmieniło" -zapisanie w repozytorium stan plików
git commit -a -m "co sie zmieniło" -zapisanie w repozytorium stan plików wszystkich śledzonych(-a), a nie tylko tych w stage
git commit "co sie zmieniło" -zapisanie w repozytorium ale dla message otworzy się notatnik aby wpisać zmianę
komenda commit robi obiekt kommit i obiet tree, snapshot jest wskazaniem na oba elementy(jest też synonimem commitu, commit robi snapshot)
staging area - poczekalnia, przechowuje pliki dodane 'add' 
git repository - przechowuje obiekty stworzone przez gita
droga plików:
katalog roboczy -> git add -a -> poczekalnia -> git commit -> repozytorium
dodanie plików:
    git add . //dodaje caly folder
    git add -A 
    git add --all
    haczyk git add, jeśli dodasz plik(git add), zmodyfikujesz ten plik(code plik) i zrobisz komita to na serwer trafią
    zmiany z momentu git add a nie momentu robienia komita,
    git add -p //wybieramy czy dodajemy zmiane do commita
git diff //od difference porównuje plik z ostatniego commitu z tym co jest w katalogu roboczym
    linia zmieniana jest pokazywana jako usunieta plus na jej miejsce nowa linia
git mv stage.txt stage2.txt zmiana nazwy fizycznej pliku na dysku i w git z stage na stage2
.gitignore jak nie dziala to https://stackoverflow.com/questions/3833561/why-doesnt-git-ignore-my-specified-file
    swoj problem rozwiazalem przez przekopowanie plku z PMC32 i z ianę zawartości w notatniku
    obydwa były rozpoznawane przez VS code z symbolem gita ale jednak ten pierwszy nie działał
4 stany pliku w repozytorium:
    -plik nieśledzony
    -śledzony niezmodyfikowany
    -śledzony zmodyfikowany
    -śledzony w indeksie(w stage, przechowalni)

Git checkout -- plik.txt //przywraca plik że stage area

Szybkie podejzenie log:
git log --oneline

git cat-file -p nazwa folderu(dwie cyfry)plus nazwa pliku(38 cyfr)  //pokazuje co się zmieniło w pliku ale dla wersji 23 coś poszło nie tak;p
    git cat-file -p 0acadae1d1643c276bfeb60f8fb15d1885a129d3

git cat-file -t nazwa folderu(dwie cyfry)plus nazwa pliku(38 cyfr)  //pokazuje drzewo
    może odwołać się do tree czyli do drzewa(innego pliku)
    może do commit np. jak dodaliśmy plik 
jeśli stworzymy dwa pliki z taką samą zawartościa to w folderze objects nic się nie zmieni, bo git tworzy obiekty dla treści a nie plików, dalej plik będzie widziany w stage

git hash-object nazwaPliku.txt // podajenumer 40 cyfrowy pliku, ale nie zmiany(o której mowa u góry)

jeśli wrzucisz link do pliku w filderze git, to bedzie śledził link ale nie zawartość pliku


Kod gotowy do wstawienia na serwer:
cd existing-project
git init
git add --all
git commit -m "Initial Commit"
git remote add origin http://kwisniewski@bitbucket.radwag.net:7990/scm/prvnlis/demorepository.git
git push -u origin master

Żeby wysłać już wielokrotnie dodawany katalog:
git add --all
git commit -m "Troche polecen"
git push -u origin master 

lub dla jednego pliku 
git add .\git_komendy.txt
git commit -m "Dodatek" 
git push -u origin master 

wykasowanie przykładowych danych logowania
git config --global --unset  user.email

git config --global user.name "FIRST_NAME LAST_NAME"
git config --global user.email "MY_NAME@example.com"

//-----------------------------------Inzynierka
git init
git config --local user.name "Konrad Wisniewski"
git config --local user.email konrad.wisniewski87@gmail.com
git remote add origin https://wisniewski87@bitbucket.org/wisniewski87/quadrokopter.git
git pull
git add --all
git commit -m "Pierwszy kommit"
git push -u origin master
//-----------------------------Wywaliła błąd
To https://bitbucket.org/wisniewski87/quadrokopter.git
 ! [rejected]        master -> master (non-fast-forward)
error: failed to push some refs to 'https://wisniewski87@bitbucket.org/wisniewski87/quadrokopter.git'
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Integrate the remote changes (e.g.
hint: 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.

jak nie po dobroci to:
git push --force

Podmiana zdalnego repozytorium, chciałem przejść z radwagowego bitbucket na prywatny git hub
Nie działa:
    git remote add origin https://github.com/konradwisniewski87/Git_komendy.git 
    fatal: remote origin already exists.
Działa: git remote set-url origin https://github.com/konradwisniewski87/Git_komendy.git
sprawdzenie adresu:
    git remote -v
    albo:
    git remote get-url --push origin
Wypchniecie repozytorium: 
    git push -u origin master
    sa wszystkie komity
Scalanie galezi branch, przechodzimy na mester i do niej mergujemy branch test:
     git checkout master
     git merge test 

Pobranie wszystkich zmian ze zdalnego repozytorium(chyba na wszystkich gałęziach)//https://stackoverflow.com/questions/21651185/git-merge-a-remote-branch-locally
git fetch --all

Jak mam zmiany i chce scalić w przód nie tracąc ich
git fetch --all
git stash
git pull
git stash pop   //stash -> stos

Sprawdzanie repozytorium zdalnego i lokalnego jako graf
git log --oneline --graph --all  

<<<<<<< Updated upstream
git pull -> to jest fetch i merge w jednym
=======
git pull -> to jest fetch i merge w jednym

jak wyswietla tylko lokane zmiany to wpisujemy 
git log origin --oneline


łączenie gałęzi:
git chckout master
git merge develop 

zmniany w repozytorium:
git commit ----amend
>>>>>>> Stashed changes
